1. Introduction To Serverless And Cloud Native

            The Evolution of Cloud Native
            From Hardware to Cloud
            Containers
            Container Orchestration
            Serverless

2. Introduction To Serverless Security
  
            Patching Operating System Dependencies
            Surviving Denial of Service Attacks
            No More Long-Lived Compromised Servers

3. CLAD Model For Serverless Security
  
            Code Vulnerabilities
            Injection Flaws
            Treat Every Function as a Perimeter
            Summary of Injection Flaws
            Library Vulnerabilities
            What’s a Known Vulnerability?
            The Hidden Burden of Using Third-Party Libraries
            Securing Vulnerable Libraries at Scale
            Proactively Apply Security Fixes
            Know Your Inventory
            Eliminate Vulnerabilities Before Functions Are Deployed
            Don’t Let Deployed Functions Lag Behind
            Controls to Minimize Library Vulnerabilities
            Summary of Library Vulnerabilities
            Access and Permissions
            Least-Privilege Principle
            Isolate Functions
            Controls to Minimize Insecure Access and Permissions
            Summary of Access and Permissions
            Data Security
            Secure and Verify Data in Transit
            Manage Function Secrets in Secure Storage
            Rotate Keys and Credentials Regularly
            Function Information Exposure
            Controls to Mitigate Sensitive Data Exposure
            Summary of Data Security

4. Securing A Sample Application
  
            Project Setup
            Setting Up an Azure Functions Account
            Deploying the Project
            Code Injection Through Library Vulnerabilities
            The Severity of Third-Party Library Vulnerabilities
            Deploying Mixed-Ownership Serverless Functions
            Circumventing Function Invocation Access
            Summary of the Sample Application
